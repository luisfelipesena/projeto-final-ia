Correção da Navegação e Depósito do Robô Mecanum no Webots: Abordagens Teóricas e Práticas

Introdução

Robôs móveis com rodas Mecanum, como o KUKA youBot, possuem alta manobrabilidade holonômica, mas isso traz desafios de controle realista em simulação. No simulador Webots, observou-se que a atual lógica de navegação fuzzy do robô exibe comportamentos pouco naturais – por exemplo, rotações de 360° desnecessárias e movimentos laterais abruptos incompatíveis com veículos reais. Além disso, o sistema de depósito de cubos em caixas coloridas apresenta falhas de alinhamento: mesmo detectando corretamente a cor e chegando próximo do alvo, o robô às vezes larga o cubo fora da caixa, exigindo múltiplas tentativas frustradas. Este relatório investiga abordagens para: (1) ajustar a navegação fuzzy para imitar restrições de direção car-like (veículo Ackerman), tornando os movimentos mais realistas em espaços estreitos com obstáculos laterais; (2) melhorar a precisão no estágio de depósito de objetos, reduzindo erros de posicionamento do cubo; e (3) propor arquiteturas híbridas (FSM + fuzzy + heurísticas) aproveitando que o ambiente (arena, obstáculos fixos, caixas) é completamente conhecido, com cubos aparecendo em posições aleatórias. Já estão disponíveis sensores de distância (LIDAR e IR frontal/traseiro), odometria com correção periódica por ground truth, planejamento global A* em grade de ocupação, e reconhecimento de cubos via câmera RGB (MobileNetV3) – recursos que serão considerados nas soluções. A seguir, apresentamos a fundamentação teórica, exemplos práticos em repositórios, análise comparativa e recomendações para resolver os problemas identificados.

Navegação Fuzzy com Restrições de Veículo (Car-Like)

Controles fuzzy são populares em robótica móvel por sua capacidade de incorporar conhecimento heurístico e lidar com incertezas. Entretanto, em robôs omnidirecionais com rodas Mecanum, um controlador fuzzy ingênuo pode explorar toda liberdade holonômica, gerando manobras não intuitivas. Restringir o comportamento para imitAR um veículo Ackerman (car-like) pode produzir trajetórias mais suaves e previsíveis. Por exemplo, em vez de permitir rotações instantâneas em qualquer ângulo, o fuzzy pode ser configurado para privilegiar giros graduais enquanto o robô se desloca para frente, similar ao esterçamento de um carro.

Estudos com robôs de direção Ackerman mostraram arquiteturas fuzzy eficazes combinando múltiplos sub-controladores e FSM. Lin et al. (2023) implementaram um controle de navegação fuzzy para um robô Ackerman usando LiDAR, onde um gerenciador de comportamentos alterna entre dois modos: deslocamento em direção à meta e seguir-parede para desviar de obstáculos ￼ ￼. Nesse sistema híbrido, três controladores fuzzy especializados (movimento reto, curva à direita, curva à esquerda) atuam durante o comportamento de seguir paredes, escolhidos conforme a distância e ângulo para a parede/obstáculo ￼ ￼. A saída fuzzy ajusta apenas o ângulo de esterçamento do robô, garantindo curvas suaves sem rotações abruptas, simulando a dinâmica de um carro. Essa abordagem inspira a restrição do movimento do youBot: ainda que possua rodas Mecanum (holonômicas), podemos deliberadamente limitar graus de liberdade no controle – por exemplo, evitar translação pura lateral e rotações no lugar a não ser quando estritamente necessárias. Assim, o robô navegaria predominantemente para frente, ajustando a orientação gradualmente, o que é mais realista em espaços confinados.

Além de FSMs, outra técnica para domar a onidirecionalidade é incorporar fatores de penalização no próprio sistema fuzzy. Poderiam ser definidas regras fuzzy que desencorajam mudanças bruscas de orientação. Por exemplo, usar a diferença angular para a meta como entrada e projetar funções de pertinência que resultem em velocidades angulares pequenas se o ângulo de desvio for moderado – evitando giros de 180° quando uma curva leve bastaria. A base Mecanum permite rotações rápidas e deslocamentos laterais, mas um controle fuzzy bem ajustado pode simular restrições não-holonômicas, produzindo trajetórias mais naturais. Abordagens na literatura de fuzzy adaptativo também podem ajudar: um controlador PID adaptado por fuzzy consegue reduzir os erros de trajetória considerando fatores como deslizamento das rodas Mecanum ￼ ￼. Cao et al. (2022) propuseram um PID adaptativo fuzzy para um robô com oito rodas Mecanum, melhorando a estabilidade e precisão de movimento ao ajustar ganhos conforme erros de cinemática e fatores de atrito ￼ ￼. Isso sugere que integrar correções dinâmicas (e.g. aumentando suavemente o controle direcional quando é detectado derrapagem ou oscilações) tornará o movimento mais fiel.

Outra vertente teórica relevante são os sistemas fuzzy de tipo-2 e controladores híbridos inteligentes. Bui et al. (2025) desenvolveram um planejador de caminho em tempo real para robô Mecanum combinando RRT* e um controlador fuzzy intervalar do Tipo-2, visando lidar com incertezas e dinâmica ￼ ￼. Controladores Type-2 conseguem modelar a incerteza nas funções de pertinência, potencialmente evitando decisões extremas do fuzzy tipo-1 clássico. Assim, no contexto do youBot, um fuzzy intervalar poderia impedir ações drásticas (como rodar 360°) quando as entradas dos sensores são ambíguas ou ruidosas – tornando a resposta mais robusta e moderada. Em suma, a teoria sugere que um controle fuzzy com restrições deliberadas (seja via FSM comportamental, regras penalizadoras, ou fuzzy adaptativo/type-2) pode adequar a navegação holonômica a padrões mais semelhantes aos de um veículo convencional, beneficiando sobretudo a circulação entre paredes ou em corredores estreitos.

Referências Práticas: Controle de Robôs Mecanum no Webots

Para avaliar soluções, é útil examinar implementações existentes de controle de rodas Mecanum no Webots. Encontramos alguns repositórios e projetos relevantes no GitHub:
	•	Webots-SummitXL (ROS2) – Projeto open-source de exploração autônoma e desvio de obstáculos usando o robô Summit XL (base mecanum da Robotnik) em Webots ￼. Esse projeto utiliza ROS2 (Foxy) e uma arquitetura modular com cinco componentes principais (mapeamento, planejamento, controle, etc). Embora não específico sobre fuzzy, ele demonstra movimentação omnidirecional realista com LIDAR e planejamento global. O README e relatório do autor indicam uso de planejamento local reativo para evitar obstáculos sem movimentos não naturais (provavelmente usando algoritmos como Dynamic Window Approach ou similar). Isso serve de referência de que é possível ter navegação suave de robô Mecanum em Webots, integrando planejamento e controle reativo.
	•	Kinematic-Omniwheels-in-Webots – Repositório que implementa as equações cinemáticas de um robô omni (4 rodas Mecanum) e controle PID simples ￼ ￼. Inclui derivações de cinemática inversa e direta e diagramas de controle PID. Esse projeto foca em controle de baixo nível: dado um vetor de velocidade desejado (vx, vy, ω), calcula as velocidades de cada roda e aplica PID para segui-las. O resultado mostrado inclui um teste de trajetória circular e ponto-a-ponto ￼, comprovando que com a cinemática correta e ganhos adequados, o robô segue trajetórias holonômicas suaves. Para nosso caso, isso implica que uma base bem calibrada não deve apresentar travamentos ou oscilações na rotação – problemas como o relatado em fórum (rodas Mecanum só indo para frente/trás devido atrito) foram corrigidos em versões recentes do Webots (ajuste de ContactProperties das rodas) ￼. Em suma, este repositório confirma a importância de modelagem cinemática fiel e controle contínuo para movimento realista.
	•	VRAC Webots Eurobot – Exemplos de simulação para a competição Eurobot, incluindo um robô holonômico de 4 rodas omni com odometria, LIDAR e câmera ￼. Há controladores de teleop (gamepad) e um AutonomousHolonomic que executa uma sequência de movimentos (lista de posições). Notavelmente, os autores alertam que “a física simulada não é perfeita!” ￼, indicando que algumas discrepâncias de movimentação podem ocorrer. Ainda assim, esse exemplo mostra uma integração de sensores e controles de alto nível (por exemplo, percorrendo pontos predeterminados) em uma base mecanum. Isso sugere que, na prática, combinar controle aberto (open-loop) para trajetórias planejadas com feedback de odometria pode funcionar, mas são necessários ajustes finos e possivelmente correções periódicas (como já adotado no youBot via ground truth).
	•	Controle Fuzzy em Webots – Embora não tenhamos encontrado um repositório público específico de fuzzy para Mecanum, existem exemplos para outros robôs. Um deles é o FuzzyLogic-Robot-Controller de AdelAKA, implementando um controlador fuzzy de desvio de obstáculos para um robô com sensores de proximidade em Webots ￼ ￼. Ele baseia-se num artigo científico e ajusta as funções de pertinência para calcular velocidades das rodas a partir das leituras dos sensores, evitando colisões. Apesar de provavelmente aplicado a um diferencial (e não mecanum), este projeto mostra a estrutura de um controlador fuzzy no Webots e como entradas de múltiplos sensores podem ser combinadas. Portanto, pode servir de guia para implementar ou depurar o sistema fuzzy existente do youBot. Em especial, poderíamos reutilizar ideias de fuzzificação de distâncias laterais para melhorar como o robô Mecanum lida com paredes próximas – talvez diminuindo sua velocidade linear ou evitando translações laterais quando sensores IR indicam espaço estreito.

Além desses, vale mencionar que o Webots traz modelos mecanum já configurados, como o REC Fabtino (plataforma logística de 4 rodas mecanum) e o próprio KUKA youBot ￼. A comunidade Webots tem discutido questões de controle Mecanum; por exemplo, um bug de 2023 relatava comportamento errático ao girar (rodar intermitente) possivelmente devido a atrito incorreto, mas foi solucionado em atualizações ￼. Isso reforça a necessidade de manter o simulador atualizado e verificar parâmetros físicos (atrito, peso, torque motor) para garantir que a base mecanum reaja como esperada. Em resumo, os repositórios e recursos práticos sugerem que: (a) integrar o controle do youBot com frameworks como ROS2 e algoritmos de navegação padrão pode melhorar muito o realismo; (b) a formulação cinemática correta e ganhos de controle bem afinados evitam movimentos anômalos; e (c) controladores fuzzy no Webots já foram testados em contextos similares, podendo-se aproveitar componentes para nossa aplicação.

Aperfeiçoamento do Sistema de Depósito de Cubos

No desafio proposto, o robô deve largar cubos coloridos em caixas fixas correspondentes. Apesar de identificar a cor corretamente e posicionar-se aproximadamente, ocorrem falhas de alinhamento fino: o cubo cai fora ou na borda da caixa, obrigando novas tentativas. Para resolver isso, precisamos melhorar tanto o alinhamento final quanto a verificação de sucesso do depósito.

Uma estratégia fundamental é explorar o fato do ambiente ser conhecido e fixo para realizar alinhamento de precisão. Ou seja, podemos pré-mapear a posição exata e orientação das caixas de destino e usar sensores para alinhar o robô a essas referências. Um exemplo exitoso disso vem do RoboCup@Work: Holz e Behnke (2014) demonstraram um youBot modificado capaz de posicionar objetos com precisão milimétrica em cavidades específicas ￼. Eles combinaram navegação grosseira via AMCL (localização por LIDAR) com um ajuste fino baseado em ICP (Iterative Closest Point): ao aproximar-se da estação de depósito, o robô comparava a leitura atual do laser com um scan de referência previamente registrado e calculava pequenas correções para encaixar as duas leituras ￼ ￼. Essa técnica de scan matching guiou o robô até a posição exata previamente aprendida, compensando erros de odometria/localização. No nosso caso, poderíamos implementar algo similar: por exemplo, ao chegar na vizinhança da caixa de destino (digamos a 20 cm de distância), congelar a posição desejada e usar o LIDAR frontal para escanear a caixa/entorno; depois, comparar com um perfil esperado (já que o ambiente é fixo) e ajustar a pose do robô (via pequenos movimentos fuzzy ou PID) até minimizar a diferença. Isso garantiria que o robô esteja centrado em relação à caixa antes de depositar o cubo. Mesmo sem ICP completo, podemos usar medições simples: alinhar o robô paralelamente à parede/base da caixa medindo distâncias laterais (sensores IR nas laterais podem ajudar, ou o próprio LIDAR detectando as bordas da caixa) e garantir uma distância frontal exata (ex.: o sensor frontal lê X cm quando o robô está na distância ideal de depósito).

Outra melhoria crítica é introduzir um ponto de espera (standoff) e abordagem controlada na sequência de depósito. O procedimento adotado em manipulações clássicas (como em cursos de robótica da Northwestern University ￼ ￼) é dividir o movimento em etapas: (1) mover o objeto para uma posição acima/do lado do alvo (ponto de espera), (2) alinhar orientação do objeto com o receptáculo, (3) descer ou avançar lentamente até a posição final, (4) soltar o objeto, e (5) recuar para o ponto de espera. Para o youBot, isso significaria: aproximar o cubo sobre a caixa pela parte superior (se possível) ou frontalmente a poucos centímetros de folga; pausar para estabilizar; então executar o movimento final de depósito em baixa velocidade e controlado. Esse micro-ajuste final, possivelmente controlado por fuzzy refinado ou por um simples controle proporcional, assegura que o cubo esteja alinhado no momento de soltar. Se o cubo for depositado pela parte superior da caixa (top-down), fixar a orientação do primeiro eixo do braço apontando para o interior da caixa simplifica o cálculo de inversa, como mostrado por uma solução de cinemática para youBot ￼ ￼ – ao manter o braço sempre perpendicular ao local de depósito, minimizamos erros laterais. Caso o depósito seja frontal (empurrando o cubo para dentro), seria importante que o robô esteja colinear à caixa; para isso, usar dois sensores IR frontais (um à esquerda e um à direita do chassi) para igualar as distâncias até a frente da caixa pode garantir centragem.

A verificação pós-depósito também deve fazer parte do sistema. Supondo que a câmera RGB ou outros sensores possam confirmar se o cubo realmente ficou na caixa: por exemplo, a câmera poderia ver a cor do cubo agora próxima à cor de fundo da caixa, ou o LIDAR poderia detectar o cubo dentro (uma leitura extra de ponto dentro da caixa). Uma solução simples: após soltar o cubo, o robô pode recuar alguns centímetros e tirar uma foto do caixa; usando visão computacional (segmentação de cor ou detecção por IA), verificar se o cubo está presente no interior. Alternativamente, se isso for complexo em tempo real, podemos usar feedback do próprio braço: ao abrir a garra, checar se o cubo foi de fato liberado (sensor de esforço na garra indicando alívio de peso) e talvez empurrar levemente para certificar que não ficou preso na garra. Se alguma dessas verificações falhar, o sistema deve acionar um plano de recuperação: por exemplo, tentar reposicionar – o robô poderia recuar uma distância fixa, deslocar-se alguns centímetros para um lado (em caso de erro lateral) e tentar avançar e depositar de novo. É crucial, porém, ter um limite de tentativas para não entrar em laço infinito; após, digamos, 2 tentativas falhas, o robô poderia marcar aquele alvo como problema e seguir para outro, ou pedir ajuda (se fosse um cenário real de competição, isso evitaria perda de tempo excessiva).

Para ilustrar, exemplo de fluxo otimizado de depósito:
	1.	Navegação à Caixa – o robô segue o caminho planejado até uma posição a ~15 cm da caixa alvo.
	2.	Alinhamento Grosso – utiliza os sensores de distância laterais/traseiros para alinhar-se paralelamente à estrutura da caixa ou parede de referência. Poderia girar lentamente até os sensores indicarem distâncias iguais dos lados (caixa centrada à frente).
	3.	Aproximação ao Ponto de Espera – move-se à posição de espera (ex.: braço a 10 cm acima da borda da caixa, ou cubo a 5 cm antes de entrar).
	4.	Alinhamento Fino – ativa modo de micro-ajuste: usando LIDAR frontal, mede a distância aos cantos da caixa (ou reflexão interna) e ajusta x, y, θ do robô em pequenos incrementos até atingir tolerância de, p.ex., <1 cm de erro. (Se LIDAR não resolve, usar odometria ground truth aqui, já que está disponível, para posicionar exatamente nas coordenadas conhecidas da caixa).
	5.	Depósito – com o robô alinhado e estabilizado, estende o braço/empurra o cubo lentamente para dentro da caixa. Abre a garra para liberar.
	6.	Confirmação – recua o braço e o robô ligeiramente. Tira leitura da área: se confirmação positiva (cubo presente na caixa), concluir; senão, proceder à etapa de recuperação.
	7.	Recuperação (se necessário) – caso o cubo tenha caído fora: talvez ele esteja visível no chão; o robô pode tentar uma recolha de erro (pegar de novo) e/ou reajustar o alinhamento (eixo de aproximação diferente – ex: se falhou pela esquerda, ajustar para direita) e repetir as etapas 3-5. Implementar no controle fuzzy uma prioridade para este estado, suprimindo outros comportamentos até resolver (evita que um obstáculo irrelevante desvie o robô no meio do depósito).

Com essas medidas, espera-se reduzir drasticamente as falhas. Devemos ainda considerar limitações físicas: o Webots simula colisões, então choques da garra com a caixa podem alterar a posição do robô ou do cubo. Por isso, os movimentos lentos e a parada no ponto de espera antes do contato são importantes para evitar rebotes. Na RoboCup@Work, a solução de Holz & Behnke fixou o primeiro link do braço e calculou as juntas para movimentos top-down precisamente, conseguindo repetibilidade sub-milimétrica ￼ ￼ – ou seja, o braço do youBot é capaz de depositar com alta exatidão se o base link estiver no lugar certo. Tudo converge para garantir que a plataforma móvel esteja bem posicionada, daí a ênfase no alinhamento pelo próprio robô móvel antes do ato de soltar o cubo.

Arquitetura Híbrida Proposta (FSM + Fuzzy + Heurísticas)

Considerando os pontos anteriores, propomos uma arquitetura de controle híbrida que combina máquina de estados finitos (FSM) para orquestração das etapas da tarefa, controladores fuzzy (ou outros contínuos) para movimentos dentro de cada etapa, e heurísticas específicas para casos excepcionais. A FSM define estados correspondentes às subtarefas: Busca do Cubo, Navegação até Cubo, Coleta/Pegar Cubo, Navegação até Depósito, Alinhamento Fino e Depósito, Verificação/Recuperação. Cada estado tem critérios claros de transição, e dentro de cada um podemos empregar controle fuzzy adaptado ao contexto:
	•	Estado: Buscando Cubo – Rotaciona e varre com câmera até identificar um cubo solto. Controle: pode usar um comportamento fuzzy de exploração (por exemplo, mantendo distância de paredes via LIDAR enquanto gira procurando cores). Transição: avança quando um cubo da cor desejada é detectado e localizado.
	•	Estado: Navegar até Cubo – Gera um caminho global (A* sobre a grade conhecida) até um ponto próximo do cubo. Controle: seguir o caminho usando um fuzzy de acompanhamento de trajeto com evitação de obstáculos. Aqui um híbrido é interessante: o caminho A* dá um alvo temporário; um controlador tipo seguir-parede fuzzy pode evitar colisões se surgir obstáculo não previsto ou para contornar cantos suavemente, sem perder a direção geral ￼. Importante, neste estado podemos relaxar as restrições car-like para aproveitar a holonomia se necessário (por ex., um leve deslocamento lateral para ajustar em frente ao cubo). Transição: ao chegar a uma distância alvo (ex: 10 cm do cubo).
	•	Estado: Coleta do Cubo – Envolve alinhamento final com o cubo e uso do braço. Controle: um conjunto de ações definidas (abrir garra, posicionar braço via IK para o cubo). Pode-se usar fuzzy para alinhar base e cubo: e.g., se o cubo não estiver exatamente em frente, um fuzzy baseado na posição relativa (vinda da câmera ou LIDAR) ajusta pequenos deslocamentos. Depois, o braço baixa, fecha garra, levanta cubo. Transição: cubo agarrado com sucesso (sensor de contato ou verificação visual).
	•	Estado: Navegar até Depósito – Similar ao navegar até cubo: usar A* até proximidade da caixa de destino. Controle: movimento car-like fuzzy (neste ponto, carregando um objeto e possivelmente em área apertada). Aqui é prudente ativar as restrições tipo carro: evitar mudança brusca pois o cubo carregado pode oscilar; e a área das caixas pode ter paredes. Então, fuzzy configura-se para giros suaves, sem strafing lateral arriscado. Transição: atingir posição de pré-alinhamento (ex: 20 cm da caixa).
	•	Estado: Alinhamento Fino e Depósito – Conforme descrito na seção anterior, fase de micro-ajuste e depósito. Controle: pode ser subdividido em sub-estados ou simplesmente um sequenciamento de movimentos lógicos. Podemos incorporar aqui um fuzzy de alinhamento fino: entradas poderiam ser diferenças de distância lateral (se caixa entre dois sensores) e diferença angular para normal da caixa, produzindo comandos de translação lateral e rotação mínimos para centralizar. Ou, dado que aqui a preferência é alta precisão determinística, poderíamos usar um controle PID direto sobre erros medidos. Uma vez alinhado, executa-se o depósito (que pode ser visto como script determinístico de movimento do braço). Transição: cubo solto; vai para Verificação.
	•	Estado: Verificação e Recuperação – Usa sensores para confirmar sucesso. Controle: predominantemente lógico: se confirmação falhou, pode chamar funções de recuperação (reposicionar e tentar novamente, ou marcar erro). Este estado representa a integração de heurísticas: por exemplo, contar tentativas, escolher deslocamento de correção (heurística: se falhou, talvez cubo caiu para fora – então recuar, fechar garra novamente no chão para recolher). Transição: se sucesso ou esgotou tentativas, finalizar missão ou retornar ao estado de busca para pegar outro cubo.

O diagrama FSM resumido ficaria: Busca -> (Cubo encontrado) -> Navega até Cubo -> (Chegou) -> Coleta -> (Pegou) -> Navega até Depósito -> (Chegou) -> Alinha/Deposita -> (Soltou) -> Verifica -> (ok? se não ok, recupera e volta a Alinhar/Depositar ou aborta). Essa máquina garante que o robô não tente fazer múltiplas coisas conflitantes – um problema comum de controles comportamentais puros – pois impõe prioridade por estados. Por exemplo, enquanto estiver depositando, a evasão de obstáculo fuzzy não irá desviar o robô da caixa (exceto detecção crítica, mas o ambiente sendo conhecido dificilmente surgirão obstáculos inesperados nessa fase).

A arquitetura híbrida também facilita integrar componentes externos: podemos acoplar facilmente o planejamento A* no estado de navegação, usar a odometria corrigida por ground truth a cada transição de estado (resetando pequenas deriva antes de iniciar uma ação crítica como pegar ou depositar), e incluir heurísticas de decisão como “se já tentei 2 cubos e falhei, talvez priorizar outro objetivo”. Essas heurísticas, não facilmente expressas em lógica fuzzy, ficam encapsuladas na FSM de alto nível.

Comparação de Abordagens e Recomendações

Com base na investigação, podemos comparar as principais abordagens de controle relevantes ao problema:

Abordagem de Navegação	Características	Vantagens	Desvantagens / Limitações
Fuzzy Puro Holonômico (sem restrições)	Regras fuzzy calculam velocidades lineares X, Y e angular livremente, permitindo movimentos em qualquer direção.	Simplicidade de implementação; reage diretamente a sensores (evita obstáculos localmente).	Pode resultar em movimentos pouco naturais (e.g. rotações de 360°) ￼; difícil garantir chegada ótima ao objetivo (pode oscilar ou escolher caminhos subótimos). Requer extenso tuning de regras.
Fuzzy com Restrições Car-like (fuzzy modificado ou tipo-2)	Controlador fuzzy configurado para se comportar como diferencial/Ackerman: prioriza avanço e curvas suaves, evita strafe lateral.	Navegação mais estável e previsível em espaços confinados (sem giros bruscos); fácil transferência a um robô real car-like.	Reduz a manobrabilidade holonômica (pode ficar preso onde strafe seria útil); ainda depende de bom tuning para não perder eficiência (ex: pode ter que dar ré para manobrar em ângulos fechados).
Planejamento Global + Fuzzy Local (híbrido hierárquico)	Algoritmo global (A*, RRT*) fornece rota desejada; controlador fuzzy segue a rota ajustando-se a obstáculos ou imprecisões.	Garante otimalidade global da trajetória (evita becos sem saída); fuzzy lida com pequenas perturbações e dinâmicas não modeladas ￼.	Integração complexa – risco do fuzzy desviar demais do caminho; precisa gerenciar conflitos (p.ex., decidir quando ignorar temporariamente o caminho para contornar obstáculo).
Abordagens Geométricas/Otimizadas (DWA, VO, MPC, etc.)	Controle baseado em modelo e otimização: Dynamic Window Approach (DWA), Velocity Obstacles (VO) ￼, controle preditivo (MPC) ￼ calculam comandos ótimos respeitando restrições físicas.	Trajetórias suaves e com garantia de evitar colisão; inclui restrições de velocidade/aceleração realisticamente; bom desempenho mesmo em ambientes dinâmicos ￼ ￼.	Mais complexo computacionalmente; requer modelo preciso do robô (e.g. dinâmica mecanum); pode ser difícil de ajustar para diferentes cenários sem reparametrizar (menos intuitivo que fuzzy).
Arquitetura FSM + Subcontroles (híbrido comportamental)	Máquina de estados gerencia modos distintos (seguir para meta, contornar obstáculo, alinhar parede, etc.), podendo usar internamente fuzzy, PID ou outros controladores especializados para cada modo ￼ ￼.	Divide o problema em partes tratáveis; evita comportamentos conflitivos; facilita adicionar heurísticas específicas (e.g. sequência de depósito). Demonstrou sucesso em navegação Ackerman complexa ￼.	Projeto e validação mais elaborados; deve-se evitar oscilações nas trocas de estado (histerese, critérios claros); número maior de parâmetros para ajustar (por controlador).

Para o caso em questão, recomenda-se um mix das abordagens acima:

1. Navegação: Utilizar planejamento global (A)* para determinar um caminho livre e curto, mas executar o trajeto com um controle local restrito. Esse controle local pode ser implementado via fuzzy adaptado (car-like) ou mesmo via uma técnica como DWA configurada para mecanum. Dado que o ambiente é estático, uma opção é Hybrid A + VO*, semelhante ao trabalho de Shafiq et al. (2024), que uniu A* e obstáculos de velocidade para desviar de obstáculos dinâmicos ￼. No nosso contexto, obstáculos dinâmicos não existem, mas a união de planejamento e desvio reativo ainda vale para evitar colisões se a odometria falhar um pouco. Se quisermos manter fuzzy, podemos inspirar-nos no dual fuzzy de Cakir (2013) – onde dois FLCs (um para seguir meta, outro para evitar obstáculos) são coordenados ￼. Em ambientes estreitos, ative um modo “corredor” que endurece as regras de não bater lateralmente (ex.: se sensores laterais < limiar, forçar orientação paralela ao corredor).

2. Depósito: Implementar o alinhamento fino sensorial antes de soltar o cubo. Use a técnica de registrar pose-alvo da caixa e alinhar via LIDAR/IR (como descrito, semelhante ao ICP do RoboCup@Work  ￼). Além disso, modularize a sequência de depósito em sub-estado dentro da FSM: Alinhar -> Soltar -> Verificar -> possivelmente Recuperar. Isso isola bem a lógica de depósito. Recomenda-se também calibrar a posição do braço para cada caixa (talvez testar off-line e armazenar offsets, já que as caixas são fixas). Pequenos marcadores visuais nas caixas (adesivos ou padrões) poderiam ser usados pela câmera para auxiliar alinhamento – se disponíveis, um algoritmo de visão poderia complementar o LIDAR, garantindo maior confiança na posição relativa antes de depositar.

3. Correções de Odometria: Aproveitar a odometria corrigida por ground truth antes de ações críticas. Por exemplo, após chegar em frente à caixa (estado Navega até Depósito), solicitar uma leitura de ground truth (no simulador podemos obter a posição real) para zerar erros acumulados – assim o alinhamento subsequente começa com erro mínimo. Embora isso seja uma trapaça que não existe no mundo real, no contexto simulado dado, é justificável para focar no teste de lógica de controle em vez de esbarrar em limitações da simulação.

4. Parâmetros Físicos: Verificar e ajustar propriedades físicas no Webots para o youBot. Certifique-se de que o patch do Webots R2021 (que ajusta ContactProperties das rodas mecanum) esteja aplicado ￼; caso contrário, manualmente definir fricção anisotrópica adequada nas rodas (alta fricção longitudinal, baixa lateral, para permitir deslize mecanum). Isso previne comportamentos como o relatado no Issue #6059 (rodas travando ao girar) e contribui para movimentos mais lineares. Realizar também tuning das velocidades: limitar a velocidade angular máxima do robô para, por exemplo, 90°/s, para evitar giros muito rápidos que dificultam o controle durante alinhamentos finos.

5. Testes em Cenários Restritos: Avaliar o novo sistema em cenários específicos – um corredor estreito com obstáculos laterais, por exemplo – e comparar o comportamento antes/depois. Espera-se que com as restrições car-like, o robô avance sem raspar paredes, talvez reduzindo a velocidade automaticamente quando as paredes estiverem muito próximas (isso pode ser conseguido via fuzzy, lendo sensores laterais e diminuindo vx quando distâncias < limiar). Comparativamente, antes o robô poderia tentar fazer strafe ou rotações estranhas nesses espaços. Uma tabela de métricas poderia ser levantada: tempo para atravessar corredor, número de colisões ou contatos com parede, etc., com e sem o novo controle fuzzy restrito.

Em conclusão, as recomendações combinam teoria e prática: adotar um controle híbrido que use o melhor de cada abordagem – planejar globalmente, ajustar localmente com fuzzy restrito ou VO, sequenciar ações via FSM e inserir camadas de alinhamento sensorial para alta precisão. A implementação incremental dessa arquitetura (primeiro ajustar navegação fuzzy, depois depositar) permitirá depurar cada componente. A expectativa é que o robô youBot no Webots passe a se deslocar de forma mais orgânica, sem movimentos irreais, e seja capaz de depositar os cubos de forma confiável na primeira tentativa na maioria dos casos. Com isso, maximiza-se o aproveitamento das capacidades do robô (rodas mecanum omnidirecionais e braço manipulador) dentro de restrições inspiradas no mundo real, atingindo desempenho superior na arena simulada.

Referências Utilizadas: Estudos recentes de controle para bases Mecanum e Ackerman ￼ ￼ ￼ ￼, documentação e projetos Webots relevantes ￼ ￼ ￼, e trabalhos em competições de robótica aplicados ao youBot ￼ ￼, conforme citado ao longo do texto. Cada fonte contribuiu com insights para compor as soluções propostas, garantindo embasamento teórico e validação prática das recomendações.